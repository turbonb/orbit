-- Enable required extensions
create extension if not exists "pgcrypto";

-- Domain enums --------------------------------------------------------------

do $$
begin
  if not exists (select 1 from pg_type where typname = 'inquiry_status') then
    create type public.inquiry_status as enum ('new', 'contacted', 'scheduled', 'closed');
  end if;
end
$$;

do $$
begin
  if not exists (select 1 from pg_type where typname = 'blog_status') then
    create type public.blog_status as enum ('draft', 'scheduled', 'published', 'archived');
  end if;
end
$$;

-- Lookup tables -------------------------------------------------------------

create table if not exists public.service_types (
  id bigint generated by default as identity primary key,
  slug text not null unique,
  label text not null,
  description text,
  is_active boolean not null default true,
  display_order integer not null default 0,
  created_at timestamptz not null default timezone('utc', now()),
  updated_at timestamptz not null default timezone('utc', now())
);

create index if not exists service_types_display_order_idx
  on public.service_types (is_active, display_order);

create or replace function public.set_updated_at()
returns trigger
language plpgsql
security definer
as $$
begin
  new.updated_at = timezone('utc', now());
  return new;
end;
$$;

drop trigger if exists set_service_types_updated_at on public.service_types;
create trigger set_service_types_updated_at
before update on public.service_types
for each row
execute procedure public.set_updated_at();

-- Primary tables ------------------------------------------------------------

create table if not exists public.inquiries (
  id uuid primary key default gen_random_uuid(),
  full_name text not null,
  email text not null,
  phone text,
  message text,
  service_type_id bigint references public.service_types(id),
  preferred_schedule timestamptz,
  status public.inquiry_status not null default 'new',
  source text not null default 'webflow:contact',
  form_id text,
  utm jsonb not null default '{}'::jsonb,
  metadata jsonb not null default '{}'::jsonb,
  assigned_to uuid,
  responded_at timestamptz,
  created_at timestamptz not null default timezone('utc', now()),
  updated_at timestamptz not null default timezone('utc', now()),
  constraint inquiries_email_check check (email ~* '^[^@\\s]+@[^@\\s]+\\.[^@\\s]+$')
);

drop trigger if exists set_inquiries_updated_at on public.inquiries;
create trigger set_inquiries_updated_at
before update on public.inquiries
for each row
execute procedure public.set_updated_at();

create index if not exists inquiries_created_at_idx on public.inquiries (created_at desc);
create index if not exists inquiries_status_idx on public.inquiries (status);
create index if not exists inquiries_service_type_idx on public.inquiries (service_type_id);

create table if not exists public.newsletter_signups (
  id uuid primary key default gen_random_uuid(),
  email text not null,
  full_name text,
  source text not null default 'webflow:cta',
  form_id text,
  tags text[] not null default '{}',
  consented boolean not null default true,
  metadata jsonb not null default '{}'::jsonb,
  created_at timestamptz not null default timezone('utc', now()),
  confirmed_at timestamptz,
  constraint newsletter_signups_email_check check (email ~* '^[^@\\s]+@[^@\\s]+\\.[^@\\s]+$')
);

create unique index if not exists newsletter_unique_email_source_idx
  on public.newsletter_signups (lower(email), source);
create index if not exists newsletter_signups_created_at_idx
  on public.newsletter_signups (created_at desc);

create table if not exists public.blog_posts (
  id uuid primary key default gen_random_uuid(),
  slug text not null unique,
  title text not null,
  excerpt text,
  content_markdown text not null,
  hero_image_url text,
  hero_image_alt text,
  reading_time_minutes integer,
  tags text[] not null default '{}',
  status public.blog_status not null default 'draft',
  published_at timestamptz,
  created_at timestamptz not null default timezone('utc', now()),
  updated_at timestamptz not null default timezone('utc', now()),
  constraint blog_posts_slug_check check (slug ~* '^[a-z0-9]+(-[a-z0-9]+)*$')
);

drop trigger if exists set_blog_posts_updated_at on public.blog_posts;
create trigger set_blog_posts_updated_at
before update on public.blog_posts
for each row
execute procedure public.set_updated_at();

create index if not exists blog_posts_status_idx on public.blog_posts (status);
create index if not exists blog_posts_published_at_idx on public.blog_posts (published_at desc nulls last);

create table if not exists public.form_events (
  id uuid primary key default gen_random_uuid(),
  form_name text,
  source text,
  payload jsonb not null,
  processed boolean not null default false,
  error text,
  created_at timestamptz not null default timezone('utc', now())
);

create index if not exists form_events_created_at_idx on public.form_events (created_at desc);

insert into storage.buckets (id, name, public, file_size_limit, allowed_mime_types)
values (
  'lead-assets',
  'lead-assets',
  false,
  104857600,
  array['application/pdf', 'application/vnd.ms-excel', 'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet']
)
on conflict (id) do update
set
  name = excluded.name,
  public = excluded.public,
  file_size_limit = excluded.file_size_limit,
  allowed_mime_types = excluded.allowed_mime_types;

insert into storage.buckets (id, name, public, file_size_limit, allowed_mime_types)
values (
  'marketing-media',
  'marketing-media',
  true,
  209715200,
  array['image/png', 'image/jpeg', 'image/webp', 'image/svg+xml']
)
on conflict (id) do update
set
  name = excluded.name,
  public = excluded.public,
  file_size_limit = excluded.file_size_limit,
  allowed_mime_types = excluded.allowed_mime_types;

-- RLS -----------------------------------------------------------------------

alter table public.service_types enable row level security;
alter table public.inquiries enable row level security;
alter table public.newsletter_signups enable row level security;
alter table public.form_events enable row level security;
alter table public.blog_posts enable row level security;

create policy if not exists "Service type list is public"
  on public.service_types
  for select
  using (true);

create policy if not exists "Service types manageable by service role"
  on public.service_types
  for all
  using (auth.role() = 'service_role')
  with check (auth.role() = 'service_role');

create policy if not exists "Inquiries viewable by authenticated"
  on public.inquiries
  for select
  using (auth.role() = 'authenticated' or auth.role() = 'service_role');

create policy if not exists "Inquiries insert via service role"
  on public.inquiries
  for insert
  with check (auth.role() = 'service_role');

create policy if not exists "Inquiries update via service role"
  on public.inquiries
  for update
  using (auth.role() = 'service_role')
  with check (auth.role() = 'service_role');

create policy if not exists "Inquiries delete via service role"
  on public.inquiries
  for delete
  using (auth.role() = 'service_role');

create policy if not exists "Newsletter readable by authenticated"
  on public.newsletter_signups
  for select
  using (auth.role() = 'authenticated' or auth.role() = 'service_role');

create policy if not exists "Newsletter write via service role"
  on public.newsletter_signups
  for insert
  with check (auth.role() = 'service_role');

create policy if not exists "Newsletter update via service role"
  on public.newsletter_signups
  for update
  using (auth.role() = 'service_role')
  with check (auth.role() = 'service_role');

create policy if not exists "Newsletter delete via service role"
  on public.newsletter_signups
  for delete
  using (auth.role() = 'service_role');

create policy if not exists "Published blog posts readable by anon"
  on public.blog_posts
  for select
  using (
    status = 'published'
    and (published_at is null or published_at <= timezone('utc', now()))
  );

create policy if not exists "Manage blog posts via service role"
  on public.blog_posts
  for all
  using (auth.role() = 'service_role')
  with check (auth.role() = 'service_role');

create policy if not exists "Form events readable by service role"
  on public.form_events
  for select
  using (auth.role() = 'service_role');

create policy if not exists "Form events write via service role"
  on public.form_events
  using (auth.role() = 'service_role')
  with check (auth.role() = 'service_role');

-- Storage RLS

create policy if not exists "Lead assets accessible to authenticated"
  on storage.objects
  for select
  using (
    bucket_id = 'lead-assets'
    and (auth.role() = 'authenticated' or auth.role() = 'service_role')
  );

create policy if not exists "Lead assets manageable by service role"
  on storage.objects
  for all
  using (bucket_id = 'lead-assets' and auth.role() = 'service_role')
  with check (bucket_id = 'lead-assets' and auth.role() = 'service_role');

create policy if not exists "Marketing media readable publicly"
  on storage.objects
  for select
  using (bucket_id = 'marketing-media');

create policy if not exists "Marketing media manageable by service role"
  on storage.objects
  for all
  using (bucket_id = 'marketing-media' and auth.role() = 'service_role')
  with check (bucket_id = 'marketing-media' and auth.role() = 'service_role');
